# migae Keychains

A Datastore entity is a pair of a
link:https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/Key[Key]
and a
link:https://cloud.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/PropertyContainer[PropertyContainer].
The migae api represents these as _keychains_ and _maps_,
respectively (see link:Entities.md[Entities] for info on the latter).

A Datastore Key is a peculiar creature.  An object of class
`com.google.appengine.api.datastore.Key` "looks like" a Key object,
but in fact it is a link in a linked list of Key objects, and it is
the entire list that serves to identify Entity object.  Hence migae
uses the terms _keychain_ to refer to this list, and _keylink_ to
refer to particular links in such a list.

A _proper keychain_ is a vector of keywords, each of which is
namespaced.  For example: `[:Foo/Bar :Baz/Buz]` is a proper keychain.
An _improper_ (or _partial_) _keychain_ is like a proper keychain
except that the last link is not namespaced; for example,
`[:Foo/Bar :Baz]`.

### anatomy of a Datastore Key

With migae we never have to deal directly with Datastore Key objects,
but it is useful to understand how they work.  A Key is composed of:

* a _kind_ of type `String`
* an _identifier_, which can be either
 * a _name_ of type string, or
 * an _id_ of type `long`
* optionally, a _parent_ key
* (hidden: a namespace string)

If you print an Entity to stdout you'll see something like the following:

```
[Subfamily("Felinae")/Genus("Felis")/Species("Felis_catus")]
```

This is the print representation of a Key whose final node has kind
"Species" and name "Felis\_catus", with a parent Key whose kind
is "Genus" and whose name is "Felis", etc.  The _root link_ has kind
"Subfamily" and name "Felinae".

link:https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Generating_keys[Constructing Keys with the Java API]
is a fairly complex matter; Clojure makes it trivial.  Instead of:

```java
Key k = new KeyFactory.Builder("Person", "GreatGrandpa")
                      .addChild("Person", "Grandpa")
                      .addChild("Person", "Dad")
                      .addChild("Person", "Me")
                      .getKey();
```

we write

```
(ds/keychain [:Person/GreatGrandpa :Person/Grandpa :Person/Dad :Person/Me])
```

You can see that a keychain is just a vector of keywords.  The only
constraint is that each keyword must be namespaced; so for example
`[:A/B :C :D/E]` would not be accepted as a keychain since it contains `:C`,
an element (aka "keylink") with no namespace.

Note: numeric ids require a syntactic hack, since e.g. `:Foo/13` is
not a valid keyword.  So we write instead `:Foo/d13` (decimal
notation) or `:Foo/x0D` (hex).

# keychains and entity-map construction

A proper (or "total") keychain is a vector of keywords, all of which
are namespaced.  But to construct a key we can ask the Datastore to
autogen a long `id`.  In that case we use a _partial keychain_, one
whose last link is just a kind keyword (one without a namespace).  For
example:

```
(entity-map [:Foo/Bar :Baz] {:a 1})
```

This might produce something like `[:Foo/Bar :Baz/7]`.  The numeric id
will be generated by the Datastore - see
link:https://cloud.google.com/appengine/docs/java/datastore/entities#Java_Assigning_identifiers[Assigning identifiers].


# keys and the datastore

When you save an Entity with a multi-link keychain to the datastore,
the keychain is of course stored as part of the Entity.  But the links
in the chain are not stored as Entity keys.  In other words, you don't
have to store an Entity for each link in a keychain, and conversely,
just because you have a keylink that formed part of a stored Entity
Key doesn't mean you can retrieve an Entity for that keylink.

# keychains in queries

Datastore supports _kind queries_, which retrieve all Entities having
a specified kind.  Such a query can also specify an "ancestor"
keychain.  In migae this is easily expressed using a _partial
keychain_, which is a vector of keywords, all of which except the last
are namespaced.  For example:

```
[:Subfamily/Felinae :Genus]
```

Used as a query specification, this would match all Entities having
kind `:Genus` and having parent Key `Subfamily("Felinae")` - the
family link:https://en.wikipedia.org/wiki/Felinae[Felinae] includes, in
addition to genus _Felis_, _Leopardus_, _Lynx_, _Puma_, and several
others, so this might match `[:Subfamily/Felinae :Genus/Felis]`,
`[:Subfamily/Felinae :Genus/Leopardus]`, etc.

#### other (old) notes

# Ancestry - i.e. Keys, Keychains, and Keylinks

The identity of a datastore entity is determined by its key; two
entities are equal if they have equal keys.  In other words, the
Entity method "equals" tests for key equality.

The language of Keys is a little confusing and obscure.  Migae tries
to make things a little more explicit and clear.

A "Key" is composed of a pair of a Kind and an Identifier (either a
string name or a long id), plus a parent key.  This recursive
structure establishes an "ancestor path" for each key.  The native API
does not provide a "getAncestors" method; to construct the entire path
you have to recur using getParent.

Note that there is an inherent ambiguity here.  The key of an Entity
is a Java object that may refer to a parent key - another object.  But
Entities are not identified solely by their key object - it's the
entire chain of keys determined by the parent chain that functions as
the key of the entity.  The Entity's key object is actually the last
link in a chain of keys.  If you call getKey on an Entity, you don't
get the entire chain of key objects.  For that, you have to recur using
getParent.

In other words, when the DS doco says "Key", it might mean the entire
Key (chain) of an entity, or it might mean jus the last link in the
chain (a Key object).

Migae replaces "Key" talk with talk of Keychains and Keylinks.

When you call getKey on an Entity, you get a Key object, which
represents the last link in the chain.  The preceding links in the
chain are represented by the getParent method of the Key class.  In
migae, we refer to keylinks rather than Keys, and keychains rather
than ancestor paths.  So e.g. `(ds/keylink e)` wraps a call to getKey,
which returns a Key, and `(ds/keychain e)` recurs over the ancestor
path to produce a vector of keylinks (represented as Clojure
keywords).  To get the ancestory path (as a vector of keywords), call
`(ds/keychain (ds/parent e))`.

The Kind of an entity is determined by the kind of its key, which is
to say by the kind of the last element in its keychain.  Ditto for its
Identifier (name or id).

This means that distinct Entities can have the same Kind and the same
Identifier, so long as they have distinct ancestor paths.  So we can
think of ancestor paths as determining a namespace.

In migae, we use the notion of a keychain to refer to the entire chain
of ancestor path plus entity Kind+Identifier, and we treat the latter
as the "name" of the Entity, the former as the namespace.  We
represent the keychain as a vector of Clojure keywords; the entire
keychain identifies the entity; the last element of the vector is the
"name" of the Entity, and the vector up to the last element represents
the ancestor path.  For example:


    [:Family/Felidae :Subfamily/Felinae :Genus/Felis :Species/Felis_catus :Cat/Chibi]

In this example, `:Cat/Chibi` is the "key node" or "name" of
the Entity, and `[:Family/Felidae :Subfamily/Felinae :Genus/Felis :Species/Felis_catus]` is
the "namespace" or ancestor path.  If you print this key from the ds
you get something like:

    [Family("Felidae")/Subfamily("Felinae")/Genus("Felis")/Species("Felis_catus")/Cat("Chibi")]

Migae wraps the gory details.  If you ask for the key of an Entity,
you get the entire keychain vector.(? - SUBJECT TO CHANGE) If you just
want the "name" part of the key (without the namespace, i.e. the
ancestor path), use ds/key-name.  ("name" is reserved for getting the
name component of a Key node).

(Note that the keys in a keychain need not be associated with actual Entities in the datastore.)

Migae uses keywords to encode Kinds and Identifiers.  The native
datastore uses String for Kinds, and either String or Long for
Identifiers ("name" and "id", respectively).

    Datastore API			migae
	Entity("MyKind")	->  (emap :Mykind) or (emap [:MyKind])
	Entity("MyKind", 99) ->  (emap :Mykind/d99) or (emap [:MyKind/d99]) or (emap (keyword "MyKind" "99"))
	Entity("MyKind, "Foo") -> (emap :Mykind/Foo) or etc.

Setting ancestry:

    Entity parent = new Entity("A", "B");
	Entity("MyKind", "Foo", parent) ->   (emap [:A/B :MyKind/Foo])

